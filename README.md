# File-Caching-Proxy
In my implementation, I have the proxy communicate with the server and create files, fetch files, or delete files when necessary. I implemented several remote procedure calls that are able to communicate to the proxy whether certain files exist on the server and also obtain metadata about files so that the proxy can then behave accordingly; in order to send file metadata to the proxy, I created a serializable file wrappers that could be sent between the proxy and server. When caching a file that has not been cached before, I have the proxy get the contents of the file on the server side and send it to the proxy in the form of a byte array. I then create a file on the proxy, write the contents into the file and cache it.

For my cache implementation, I used a linked list using the LinkedList class. The head of the list denoted the oldest file and the tail of the list denoted the newest file. Hence, queuing and dequeuing from the list when evicting served as a LRU replacement policy. Additionally, I used a hashmap to map paths to a file wrapper class that I created. The file wrapper class contained a file, random access file, and other important meta data for each file. This served as a cache to obtain information about files in the cache. I also used hashmaps to create a file table that mapped file descriptors to file wrappers. This mapping indicated which files were open for each client. I made sure to update the linked list of files and the hashmap with information about the files in order to maintain consistency between the hashmap and the linked list.

Additionally, version control was a necessary aspect of my implementation for concurrent proxies and clients. I used a hashmap on the proxy to map path names to the most recent version of a certain file and I used a hashmap on the server to map path names to version numbers. I generated version numbers on the server side using the UUID class which created unique IDâ€™s for each version of a file. I also generated version numbers on the proxy side when calling write(). Versioning was necessary when writing in order to prevent concurrent writes from writing to the same file and concurrent reads from reading from partially edited files. Once a new version of a file was created in write, they were pushed back to the server on close according to session semantics.

In order to implement whole-file caching, I fetched entire files at once and retrieved the version number from the server and cached a new version of the file. Additionally, when pushing updates back to the server, I made sure to wipe the server file, send the contents of the file we want to push to the server, and write the contents to the server file.

For evictions, I made sure to evict on close according to session semantics. I kept track of the size of the cache using a global variable and I also stored the size limit of the cache in a global variable as well. Since I also cache files in close, I make sure to evict if necessary before trying to cache.

Lastly, I used read/write locks to implement concurrency. I used a write lock when updating the server file so that no proxies would be able to retrieve a partially written to file and so that no proxies could write to a partially written to file. Additionally, I used a read lock when fetching from the server so that other proxies would not be able to write to the server file when a fetch is occuring.
